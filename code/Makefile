include Makefile.inc

# SETUPNAME is the name of the file in tests/setups/ that you want to use as
# your setup file. It should contain the implementation of the function
# testSetup() that's defined in Engine/setup.h. To use your own setup file
# instead of the default, simply edit the .gitignore'd file Makefile.testsetup
# and define a new SETUPNAME.
SETUPNAME = default.cpp
SETUPMAKEF = Makefile.testsetup

-include $(SETUPMAKEF)

BUILDDIR = build
TARGET = $(BUILDDIR)/racer
LIBDIRS = Agents Engine Graphics Network Physics Parser Sound Utilities
SETUPSDIR = tests/setups

HEADERS = $(wildcard */*.h)
C_SRCS   = $(wildcard */*.c)
CPP_SRCS = $(wildcard */*.cpp)

CTAGS = tags

#OBJNAMES = i.e. Agents/agent.o
#OBJECTBUILDS  = i.e. build/Agents/agent.o
#OBJECTS = i.e. build/agent.o

# The strategy here is to build everything into build/$(some_lib_dir)/file.o,
# hard link that object file to build/file.o, and then link as normal. this will
# fail if someone tries to make an object file with the same name as one in
# another directory, but that shouldn't happen anyway.
#
SETUPOBJ = $(BUILDDIR)/setup.o
OBJNAMES  = $(C_SRCS:.c=.o) $(CPP_SRCS:.cpp=.o)
OBJECTBUILDS = $(addprefix $(BUILDDIR)/, $(OBJNAMES))
OBJECTS = $(addprefix $(BUILDDIR)/, $(notdir $(OBJNAMES))) $(SETUPOBJ)

all: $(BUILDDIR) $(CTAGS) $(TARGET)

$(BUILDDIR):
	mkdir -p $(addprefix $(BUILDDIR)/, $(LIBDIRS))

$(CTAGS): $(HEADERS) $(C_SRCS) $(CPP_SRCS)
	ctags -R --c++-kinds=+p --fields=+iaS --extra=+q

$(TARGET): $(BUILDDIR) $(OBJECTBUILDS) $(SETUPOBJ)
	g++ $(CXXFLAGS) -o $@ $(OBJECTS) $(LDFLAGS)

.PHONY: test clean
test: all
	./$(TARGET) --track=tests/tracks/oval.trk --sounds=tests/sounds/ --ai-players=3
clean:
	rm -rf $(BUILDDIR) $(CTAGS)


# Automatic dependency generation:
# -MMD generates a file called foo.d (where foo is the argument of -o without
# the tail .o) with dependency rules for the given file, generated by looking
# at the #include statements; the extra M  means only add deps on non-system
# headers; the D means do it at the same time as compiling.
# -MP makes an empty target for each .h file that is #included, to prevent make
# from choking if you remove a header file without updating its generated
# rule file.
# -MT names the target of the rule its argument (this is for making relative
#  paths work right)
$(BUILDDIR)/%.o: %.cpp
	$(CXX) -MMD -MP -MT $@ $(CXXFLAGS) -c $< -o $@ && ln -f $@ $(BUILDDIR)/
$(BUILDDIR)/%.o: %.c
	$(CC) -MMD -MP -MT $@ $(CFLAGS) -c $< -o $@ && ln -f $@ $(BUILDDIR)/

$(SETUPOBJ): $(SETUPSDIR)/$(SETUPNAME) $(shell if [ -f $(SETUPMAKEF) ]; then echo $(SETUPMAKEF); fi)
	$(CXX) $(CXXFLAGS) -c $< -o $@

Makefile.testsetup:

# Then the autogenerated rule files are included here - the '-' in front of
# include suppresses superfluous warnings about missing .d files
-include $(OBJECTBUILDS:.o=.d)
