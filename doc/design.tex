\documentclass[12pt]{article}
\usepackage{graphicx}
\title{z-fight-club design document}
\author{Joe Doliner \and Jordan Lewis \and Nick Russo \and Matthew Steffen \and Youlian Simidjiysky}

\begin{document} \maketitle
\begin{abstract}
This document contains the high-level and component-level design of
z-fight-club's project for CMSC 23800.
\end{abstract}
\section{High-Level Design}
\subsection{Game Feel}
This is a racing game. What is it like? Does it have grappling hooks?
\subsection{Component Architecture}
\includegraphics[scale=0.2]{game.pdf}

\section{Component-Level Design}
Each component has a list of its responsibilities and an interface. These are
enumerated for each component below.
\subsection{Scheduler}
The scheduler is the top-level component of the system. It is responsible for
the main loop of the game, and for making sure that each component is run
when it needs to be without taking up more time than is it available for it.
So, the scheduler needs to tell physics, AI, controls, networking, and graphics
to conditionally update based on need every game loop
\subsection{World}
The world is the state of the system. It is a passive component that receives
and handles requests to get or set different state attributes. Some examples
of state that belongs to the world component are car
position/velocity/orientation vectors, lighting information, camera information,
and score variables if we end up having those. This component along with physics
could possibly be the same as the Engine component in the above diagram.
\subsection{Physics}
The physics component is the engine that updates the world from its current
state to a new state, by simulating how all of the objects in the world
interact over some dt. It is responsible for receiving update requests from the
scheduler, calculating how the world looks after a time delta fom the current
state, and updating the world to that new state.
\subsubsection{Interface}
\paragraph{Called by physics}
The only input the physics subsystem requires in order to calculate the next
state of the world is the current state of the world. It also must write out
the result of its calculations. Therefore, it needs the following functions:
\begin{itemize}
\item world::poll()
\item world::set()
\end{itemize}
\paragraph{Offered by physics}
The physics engine need offer only one function, namely the simulate function
that steps the world from the current state to the next state for some timestep
dt. Optionally, simulation functions that might be useful for another component
(ex. AI trying to predict the next position of a car) could be exported by
the physics class as well, but it is unclear whether such general functions
belong in the physics class or in some external physics utility library.

\begin{itemize}
\item simulate()
\end{itemize}

\subsection{Agent}
Agents are the in-game entities corresponding to car drivers. They come in
two or three categories: AI agents, human agents, and possibly network agents.
They are responsible for collecting input from different sources depending on
their category, interpreting these inputs into actions suitable to tell the
physics component, and issuing these actions to the physics component.

\subsubsection{Interface}

\paragraph{Called by agent}
\begin{itemize}
\item accelerate()
\item brake()
\item turnLeft()
\item turnRight()
\item jump()
\item shoot()
\end{itemize}
The meaning of these functions is hopefully pretty self explanatory. They should be implemented in the world class. Accelerate, brake and turn{Left,Right} should be as simple as modifying fields in it.
Jump and shoot need to be a bit more complicated, it seems like we'll need to do some scheduling. It's also not entirely clear that we'll be supporting these features.

\paragraph{Offered by agent}
\begin{itemize}
\item takeEvent(char keyEvent)
\end{itemize}
The agent also needs to be able to take raw key events and process them into the above calls.

\subsubsection{AI}
The AI component serves as the controlling input to AI agents. It is responsible
for analyzing game state and making control decisions for each individual AI
agent currently instantiated in the syste, and sending those decisions to
each corresponding agent.

\subsubsection{Interface}

\paragraph{Called by AI}
AI should get direct control of an agent instance.

It also needs to be able to poll the world and get its own position and velocity as well as those of the cars in its immediate surroundings. This can really just be one function though:
\begin{itemize}
\item poll()
\end{itemize}
A major design question I have is whether the AI should just sit in a seperate thread (or process even) and just grab data and send its descisions back up through an agent or if the world should ping the AI for its decisions. The first one would allow for the most code reuse between human and computer players but it seems like threading issues might get in the way.

\subsubsection{Controls}
The controls component serves as the controlling input to human agents. It
is responsible for sampling (or being notified of?) user input and handing it
to the corresponding agent.
\subsection{Networking}
The networking component is responsible for listening for network input and
doing the right thing with this input. The right thing may include world
synchronization and network agent control.
\subsection{Graphics}
The graphics component is the primary output of the system. It provides the
visual feedback necessary for the player to see into the game world and observe
how her input affects it. It is responsible for translating the state given
by the world component into an on-screen representation in an efficient manner.
\subsection{Sound}
The sound component translates events such as crashes, explosions, or engine
activity into audio output, and may also keep an ambient music track playing.
It fields requests like "play the crash noise" or "stop revving car C's engine"
and mixes and outputs corresponding sounds as it sees fit.

\end{document}
